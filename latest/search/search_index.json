{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"async-pmtiles","text":"<p>An asynchronous PMTiles reader for Python.</p> <p>The PMTiles format is a cloud-native, compressed, single-file archive for storing tiled vector and raster map data.</p> <p>This implementation is fully asynchronous and integrates with Obstore and Obspec for efficiently loading data from remote files.</p> <p>Documentation: developmentseed.org/async-pmtiles/</p>"},{"location":"#install","title":"Install","text":"<pre><code>pip install async-pmtiles\n</code></pre>"},{"location":"#example","title":"Example","text":"<p>The easiest way to get started is by using Obstore to fetch remote data.</p> <pre><code>from async_pmtiles import PMTilesReader\nfrom obstore.store import HTTPStore\n\nstore = HTTPStore(\"https://r2-public.protomaps.com/protomaps-sample-datasets\")\nsrc = await PMTilesReader.open(\"cb_2018_us_zcta510_500k.pmtiles\", store=store)\n\n# PMTiles Metadata\nmeta = await src.metadata()\n\n# Spatial Metadata\nbounds = src.bounds\nminzoom, maxzoom = src.minzoom, src.maxzoom\n\n# Is the data a Vector Tile Archive\nassert src.is_vector\n\n# PMTiles tiles type\nsrc.tile_type\n\n# Tile Compression\nsrc.tile_compression\n\n# Get Tile\ndata = await src.get_tile(x=0, y=0, z=0)\n</code></pre>"},{"location":"#custom-client","title":"Custom Client","text":"<p>Here's an example with using a small wrapper around <code>aiohttp</code> to read from arbitrary URLs:</p> <pre><code>from dataclasses import dataclass\nfrom aiohttp import ClientSession\nfrom async_pmtiles import PMTilesReader, Store\n\n@dataclass\nclass AiohttpAdapter(Store):\n    session: ClientSession\n\n    async def get_range_async(\n        self,\n        path: str,\n        *,\n        start: int,\n        length: int,\n    ) -&gt; bytes:\n        inclusive_end = start + length - 1\n        headers = {\"Range\": f\"bytes={start}-{inclusive_end}\"}\n        async with self.session.get(path, headers=headers) as response:\n            return await response.read()\n\n\nasync def main():\n    async with ClientSession() as session:\n        store = AiohttpAdapter(session)\n        url = \"https://r2-public.protomaps.com/protomaps-sample-datasets/cb_2018_us_zcta510_500k.pmtiles\"\n        src = await PMTilesReader.open(url, store=store)\n\n        assert src.header\n        assert src.bounds == (-176.684714, -14.37374, 145.830418, 71.341223)\n        assert src.minzoom == 0\n        assert src.maxzoom == 7\n</code></pre>"},{"location":"CHANGELOG/","title":"Changelog","text":""},{"location":"CHANGELOG/#010-2026-02-10","title":"0.1.0 - 2026-02-10","text":"<p>Initial release.</p>"},{"location":"DEVELOP/","title":"Contributing","text":"<p>Issues and pull requests are more than welcome.</p> <p>First install <code>uv</code>. Then set up with:</p> <pre><code>git clone https://github.com/developmentseed/async-pmtiles\ncd async-pmtiles\nuv sync\n</code></pre>"},{"location":"DEVELOP/#running-tests","title":"Running tests","text":"<pre><code>uv run pytest\n</code></pre>"},{"location":"DEVELOP/#documentation","title":"Documentation","text":""},{"location":"DEVELOP/#building-locally","title":"Building locally","text":"<pre><code>uv run --group docs mkdocs serve\n</code></pre>"},{"location":"DEVELOP/#publishing-docs","title":"Publishing docs","text":"<p>Documentation is automatically published when a new tag with <code>v*</code> is pushed to <code>main</code>. Alternatively, you can manually publish docs by triggering the docs publish workflow from the GitHub actions UI.</p>"},{"location":"api/","title":"API Documentation","text":""},{"location":"api/#async_pmtiles","title":"async_pmtiles","text":"<p>async-pmtiles: asynchronous interface for reading PMTiles files.</p>"},{"location":"api/#async_pmtiles.PMTilesReader","title":"PMTilesReader  <code>dataclass</code>","text":"<p>An asynchronous PMTiles Reader.</p>"},{"location":"api/#async_pmtiles.PMTilesReader.bounds","title":"bounds  <code>property</code>","text":"<pre><code>bounds: tuple[float, float, float, float]\n</code></pre> <p>The bounding box of the archive as (min_lon, min_lat, max_lon, max_lat).</p>"},{"location":"api/#async_pmtiles.PMTilesReader.center","title":"center  <code>property</code>","text":"<pre><code>center: tuple[float, float, int]\n</code></pre> <p>The center of the archive as (center_lon, center_lat, center_zoom).</p>"},{"location":"api/#async_pmtiles.PMTilesReader.header","title":"header  <code>instance-attribute</code>","text":"<pre><code>header: HeaderDict\n</code></pre> <p>The underlying raw PMTiles header metadata.</p>"},{"location":"api/#async_pmtiles.PMTilesReader.maxzoom","title":"maxzoom  <code>property</code>","text":"<pre><code>maxzoom: int\n</code></pre> <p>The maximum zoom of the archive.</p>"},{"location":"api/#async_pmtiles.PMTilesReader.minzoom","title":"minzoom  <code>property</code>","text":"<pre><code>minzoom: int\n</code></pre> <p>The minimum zoom of the archive.</p>"},{"location":"api/#async_pmtiles.PMTilesReader.path","title":"path  <code>instance-attribute</code>","text":"<pre><code>path: str\n</code></pre> <p>The path within the store to the PMTiles file.</p>"},{"location":"api/#async_pmtiles.PMTilesReader.store","title":"store  <code>instance-attribute</code>","text":"<pre><code>store: Store\n</code></pre> <p>A reference to the store used for fetching byte ranges.</p>"},{"location":"api/#async_pmtiles.PMTilesReader.tile_compression","title":"tile_compression  <code>property</code>","text":"<pre><code>tile_compression: Compression\n</code></pre> <p>Return the compression type used for tiles.</p>"},{"location":"api/#async_pmtiles.PMTilesReader.tile_type","title":"tile_type  <code>property</code>","text":"<pre><code>tile_type: TileType\n</code></pre> <p>Return the type of tiles contained in the archive.</p>"},{"location":"api/#async_pmtiles.PMTilesReader.get_tile","title":"get_tile  <code>async</code>","text":"<pre><code>get_tile(x: int, y: int, z: int) -&gt; Buffer | None\n</code></pre> <p>Load data for a specific tile given its x, y, and z coordinates.</p> <p>Note that no decompression is applied.</p>"},{"location":"api/#async_pmtiles.PMTilesReader.metadata","title":"metadata  <code>async</code>","text":"<pre><code>metadata() -&gt; dict\n</code></pre> <p>Load user-defined metadata stored in the PMTiles archive.</p>"},{"location":"api/#async_pmtiles.PMTilesReader.open","title":"open  <code>async</code> <code>classmethod</code>","text":"<pre><code>open(path: str, *, store: Store) -&gt; Self\n</code></pre> <p>Open a PMTiles file.</p> <p>Parameters:</p> <ul> <li> <code>path</code>               (<code>str</code>)           \u2013            <p>The path within the store to the PMTiles file.</p> </li> <li> <code>store</code>               (<code>Store</code>)           \u2013            <p>A generic \"store\" that implements fetching byte ranges asynchronously.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If the PMTiles version is unsupported.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>           \u2013            <p>An instance of PMTilesReader.</p> </li> </ul>"},{"location":"api/#async_pmtiles.Store","title":"Store","text":"<p>               Bases: <code>Protocol</code></p> <p>A generic protocol for accessing byte ranges of files.</p> <p>This is compatible with obspec.GetRangeAsync and is implemented by obstore stores, such as S3Store, GCSStore, and AzureStore.</p>"},{"location":"api/#async_pmtiles.Store.get_range_async","title":"get_range_async  <code>async</code>","text":"<pre><code>get_range_async(path: str, *, start: int, length: int) -&gt; Buffer\n</code></pre> <p>Asynchronously fetch a byte range from a file.</p> <p>Parameters:</p> <ul> <li> <code>path</code>               (<code>str</code>)           \u2013            <p>The path to the file within the store.</p> </li> <li> <code>start</code>               (<code>int</code>)           \u2013            <p>The starting byte offset of the range to fetch.</p> </li> <li> <code>length</code>               (<code>int</code>)           \u2013            <p>The length of the range to fetch.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Buffer</code>           \u2013            <p>Byte buffer.</p> </li> </ul>"},{"location":"blog/","title":"Blog","text":""}]}